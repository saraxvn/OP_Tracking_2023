# STEP A: COCO Pose Keypoint Processor

This repository contains a Python script for processing pose estimation data in COCO format. It extracts keypoints from a JSON file, filters and reshapes the data, fills missing frames, and saves the cleaned result as a `.pkl` file.

## Features

- Extracts video dimensions and frames per second (fps)
- Parses `keypoints_coco.json` generated by pose estimation tools
- Organizes keypoints per frame for up to 3 detected individuals
- Filters out skeletons with low number of keypoints (less than 8 [0.0, 0.0] entries)
- Fills in missing frames with NaN values
- Saves the result as a `.pkl` file for further analysis

---

# Step B: Handling Known Occlusion Periods

In cases where we know certain significant occlusion times that could affect tracking, this step helps work around those by:

- Dividing the dataframe into parts
- Making occlusion segments full of NaN values
- Performing tracking on each part separately
- Reassembling the parts after tracking is done


## Logic of the Code

- Make a copy of the raw dataframe (`df_copy`) and create an empty dataframe (`new_df`) of the same size.
- Copy the first row (with all three identities present) into `new_df`.
- Fill `new_df` with numpy arrays that match the identity of the previous row in the same column.
- Matching depends on whether arrays meet conditions defined by several functions.



## Key Functions for Identity Tracking

- **`euc_distance(v1, v2)`**  
  Calculates the Euclidean distance between corresponding keypoints of two numpy arrays. Zero values are replaced with NaN to exclude missing values from the calculation.

- **`cosine_2d(v1, v2)`**  
  Calculates cosine similarity (1 - cosine distance) between two arrays, masking zero values to avoid inaccuracies.

- **`makewhateversnan_nan()`**  
  Considers rows with a certain number of NaNs and avoids tracking for missing arrays in those rows.

- **`calculate_coses()`**  
  Calculates cosine similarities among all three arrays from the previously tracked row, sorting them in descending order.

- **`calculate_distances()`**  
  Calculates distances between keypoints of two arrays; used when top cosine similarities are close, to decide the best match based on lowest sum distance.

- **`control_fakeP1_and_P2_duplicates()`**  
  Ensures there are no repeated arrays in the same row.

- **`fill_gap()`**  
  Fills gaps where some arrays are missing in `new_df` due to exceptions in matching conditions.

- **`find_person()`**  
  The main function with defined thresholds determined through trial and error, used to assign identities reliably.

- **`track_df(df_copy, new_df)`**  
  Runs the full tracking process.  
  - Defines `z` for each row as the number of rows before a non-NaN numpy array appears (to handle missing rows).  
  - Processes one person at a time in `new_df`, identified by `P_num_new` (1, 2, or 3).
 
---

# Step C involves

- Extracting video frames at certain time intervals  
- Plotting the keypoints and identities with specific colours each:  
  - P1 (child) = green  
  - P2 (assessor) = red  
  - P3 (parent) = blue  
- Superimposing the above on top of each other to check that everything was tracked correctly  
- Correcting the identities (e.g., P1 â†’ P3) if identities are consistent throughout but incorrect.  
  If needed, rerun the previous steps  
- By the end, obtaining the full corrected dataframe  

